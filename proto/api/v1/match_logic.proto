syntax = "proto3";
package api.v1;
option go_package = "github.com/rivalry-matchmaker/rivalry/pkg/pb/api/v1";

import "api/v1/messages.proto";

message MakeMatchesRequest {
  repeated Submission submissions = 1;
}

message Submission {
  // a UUID generated by the client
  string id = 1;

  // list of player ids linked to this request
  repeated string members = 2;

  // matchmaking data specific to this player / group
  MatchRequestData match_request_data = 3;

  // A queue is a collection of tickets to be matched together, it controls how tickets are matched
  string matchmaking_queue = 4;

  // A list of latency data for game server instances
  repeated RTT rtts = 5;

  // record the time the ticket was created in the db
  int64 create_time = 6;
}

message MakeMatchesResponse {
    Match match = 1;
}

message Match {
  // A UUID that should be passed through the stack for tracing.
  string match_id = 1 [json_name = "match_id"];

  // Name of the matchmaking queue this match was created on.
  string matchmaking_queue = 2 [json_name = "matchmaking_queue"];

  // Match Request IDs that belong to this match.
  repeated string match_request_ids = 3 [json_name = "match_request_ids"];

  // list of player ids linked to this request
  repeated string player_ids = 4;

  // A list of average latency data for game server instances
  repeated RTT rtts = 5;
}

service MatchMakerService {
  // MakeMatches takes a MatchProfile and a map of pool names to ticket slices, and creates
  // a slice of Match's from that information
  rpc MakeMatches(MakeMatchesRequest) returns (stream MakeMatchesResponse) {}
}


message MakeAssignmentRequest {
  Match match = 1;
}

message MakeAssignmentResponse {
  GameServer game_server = 1;
}

service AssignmentService {
  rpc MakeAssignment(MakeAssignmentRequest) returns (MakeAssignmentResponse) {}
}
